<#
.SYNOPSIS
    Converts and analyzes a Robocopy log file into a structured PowerShell object.

.DESCRIPTION
    The `ConvertFrom-RobocopLog` script processes a log file generated by Robocopy, extracting key information such as header details, classified file lists, created directories, and summary statistics.
    
    It supports both English and French log files, returning a PowerShell object containing the parsed data. The script is designed to work seamlessly with different Robocopy configurations, but certain options are required or restricted for optimal functionality (see the Notes section).

.PARAMETER RoboLog
    (Mandatory) Specifies the path to the Robocopy log file to be analyzed.

.PARAMETER LogLanguage
    (Optional) Indicates the language of the log file. Defaults to "en-US". Supported options are "en-US" and "fr-FR".

.PARAMETER IncludeFileClass
    (Optional) Specifies which file classes to include in the parsing. Possible values are "All", "NewFiles", "ModifiedFiles", "LonelyFiles", "SameFiles", "NewerFiles", "OlderFiles", "ExtraFiles", "TweakedFiles", "FailedFiles". Defaults to "All".

.PARAMETER IncludeDirClass
    (Optional) Specifies which directory classes to include in the parsing. Possible values are "All", "NewDirs", "ExtraDirs", "LonelyDirs". Defaults to "All".

.PARAMETER ExcludeFileClass
    (Optional) Specifies which file classes to exclude from the parsing. Possible values are "All", "NewFiles", "ModifiedFiles", "LonelyFiles", "SameFiles", "NewerFiles", "OlderFiles", "ExtraFiles", "TweakedFiles", "FailedFiles".

.PARAMETER ExcludeDirClass
    (Optional) Specifies which directory classes to exclude from the parsing. Possible values are "All", "NewDirs", "ExtraDirs", "LonelyDirs".

.EXAMPLE
    # Parse a Robocopy log file with default options
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.txt"
    
    # Parse a log file in English with specific file classes included
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.txt" -LogLanguage "en-US" -IncludeFileClass "NewFiles", "ModifiedFiles"
    
    # Parse a French log file excluding specific directory classes
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -LogLanguage "fr-FR" -ExcludeDirClass "NewDirs"
    
    # Parse a log file with all file and directory classes excluded (only header and summary will be parsed)
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -ExcludeFileClass "All" -ExcludeDirClass "All"

    # Accessing parsed information from the log
    $Log.HeaderInfo       : Displays the extracted header information if available.
    $Log.HeaderInfo.Start : Shows the start date and time from the header if available.
    $Log.Files.NewFiles   : Lists new files with size and timestamp, depending on the Robocopy options.
    $Log.SummaryInfo      : Displays the summary statistics if available.

    # Use Get-Member to see all properties of the returned object
    $Log | Get-Member

.NOTES
    WARNING               : For this script to work properly, certain Robocopy log options must be considered.
								(REQUIRED OPTION)  /fp              : Ensures that full file paths are logged.
								(FORBIDDEN OPTION) /nc              : Specifies that file classes will not be recorded.

								(fr-FR OPTION)     /unicode:<Log>   : To be used instead of /log for proper handling of accents.
                                                                      Be aware that in Unicode, some characters are non-breaking.
                                                                      They must be directly added to the culture map. Check fr-FR CultureMap.

                            More info: https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy

							Some data is not converted, including:
								- Folders that have not changed.
								- Copy speed from the summary.
								- Total size of the copied files from the summary.

							The script takes into account retries. In case of retries, Robocopy will reattempt classes and errors.
							A check is therefore performed to ensure that errors or file classes are not already included in the objects to avoid duplicates.
                         

    ROBOCOPY CLASSES en-US  :   File        Exists In   Exists In        Source/Dest     Source/Dest    Source/Dest
                                Class       Source      Destination      File Times      File Sizes     Attributes
                                =========== =========== ================ =============== =============  ============
                                Lonely      Yes         No               n/a             n/a            n/a
                                Tweaked     Yes         Yes              Equal           Equal          Different
                                Same        Yes         Yes              Equal           Equal          Equal
                                Changed     Yes         Yes              Equal           Different      n/a
                                Newer       Yes         Yes              Source > Dest   n/a            n/a
                                Older       Yes         Yes              Source < Dest   n/a            n/a
                                Extra       No          Yes              n/a             n/a            n/a
                                Mismatched  Yes (file)  Yes (directory)  n/a             n/a            n/a

    ROBOCOPY CLASSES fr-FR  :   Classe de   Existe dans Existe dans      Source/Dest     Source/Dest    Source/Dest
                                Fichier     la Source   la Destination   Date fichier    Taille fichier Attributs
                                =========== =========== ================ =============== =============  ============
                                solitaire   Oui         Non              n/a             n/a            n/a
                                Tweaked     Oui         Oui              Identique       Identique      Différent
                                identique   Oui         Oui              Equal           Identique      Identique
                                Modifié     Oui         Oui              Equal           Different      n/a
                                Plus récent Oui         Oui              Source > Dest   n/a            n/a
                                Plus ancien Oui         Oui              Source < Dest   n/a            n/a
                                Supplément. Non         Oui              n/a             n/a            n/a
                                Discordance Yes (Fic)   Yes (Rép)        n/a             n/a            n/a

    AUTHOR              : Letalys (Christophe Goemaere)

    SCRIPT              : ConvertFrom-RobocopLog.ps1
    SCRIPTVERSION       : 2.1

    RELEASENOTES        : Version 1.0  | 2024-09-26
                                Initial version.
			              Version 1.01 | 2024-09-27
                               Bug fix : When the $ParseType option was full, the end summary was not correctly parsed due to a bad condition
                          Version 2.0 | 2024-10-27
                                Issue #2 : New Method to browse log file. This script now integrate the log file into an array and browse it.
                          Version 2.1 | 2024-11-03
                                Issue #4 : Integration of parameters for selecting file and directory classes to return in the object. 
                                Removal of the ParseType option in favor of new options allowing you to exclude the recovery of file or directory classes to only manage the header and summary.

#>

param (
    [Parameter(Mandatory = $true)][ValidateScript({ Test-Path -Path $_ })][String]$RoboLog,
    [Parameter(Mandatory = $false)][ValidateSet("en-US", "fr-FR")][String]$LogLanguage = "en-US",
    [Parameter(Mandatory = $false)][ValidateSet("All", "NewFiles", "ModifiedFiles", "LonelyFiles","SameFiles","NewerFiles","OlderFiles","ExtraFiles","TweakedFiles","FailedFiles")][string[]]$IncludeFileClass = @("All"),
    [Parameter(Mandatory = $false)][ValidateSet("All", "NewDirs", "ExtraDirs","LonelyDirs")][string[]]$IncludeDirClass = @("All"),
    [Parameter(Mandatory = $false)][ValidateSet("All,NewFiles", "ModifiedFiles", "LonelyFiles","SameFiles","NewerFiles","OlderFiles","ExtraFiles","TweakedFiles","FailedFiles")][string[]]$ExcludeFileClass,
    [Parameter(Mandatory = $false)][ValidateSet("All,NewDirs", "ExtraDirs","LonelyDirs")][string[]]$ExcludeDirClass
)

function ConvertFrom-RobocopLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)][ValidateScript({ Test-Path -Path $_ })][String]$RoboLog,
        [Parameter(Mandatory = $false)][ValidateSet("en-US", "fr-FR")][String]$LogLanguage = "en-US",
        [Parameter(Mandatory = $false)][ValidateSet("All", "NewFiles", "ModifiedFiles", "LonelyFiles","SameFiles","NewerFiles","OlderFiles","ExtraFiles","TweakedFiles","FailedFiles")][string[]]$IncludeFileClass = @("All"),
        [Parameter(Mandatory = $false)][ValidateSet("All", "NewDirs", "ExtraDirs","LonelyDirs")][string[]]$IncludeDirClass = @("All"),
        [Parameter(Mandatory = $false)][ValidateSet("All,NewFiles", "ModifiedFiles", "LonelyFiles","SameFiles","NewerFiles","OlderFiles","ExtraFiles","TweakedFiles","FailedFiles")][string[]]$ExcludeFileClass,
        [Parameter(Mandatory = $false)][ValidateSet("All,NewDirs", "ExtraDirs","LonelyDirs")][string[]]$ExcludeDirClass
    )

    #region CultureMap
        #Management of keyword dictionaries according to language.
        $CultureMap = @{
            "en-US" = @{
                #RobocopParsing
                RobocopParsingStart    = "Start parsing..."
                RobocopParsingFinalize = "End parsing..."

                #Parsing header
                Start        = "Started :"
                Source       = "Source :"
                Destination  = "Dest :"
                FilesSection = "Files :"
                Options      = "Options :"

                #Parsing Files
                NewFile      = "New File"
                NewerFile    = "Newer"
                OlderFile    = "Older"
                SameFile     = "same"
                ExtraFile    = "EXTRA File"
                ModifiedFile = "Modified"
                LonelyFile   = "lonely"
                TweakedFile  = "tweaked"

                #Parsing Directories
                NewDir       = "New Dir"
                ExtraDir     = "EXTRA Dir"
                LonelyDir    = "lonely"

                #Error
                Error             = "ERROR"
                ErrorCopyFile     = "Copying File"
                ErrorDelFile      = "Deleting File"
                ErrorDelExtraFile = "Deleting Extra File"

                #Parsing Summary
                DirsSummary  = "Dirs :"
                FilesSummary = "Files :"
                Bytes        = "Bytes :"
                Times        = "Times :"
                Ended        = "Ended :"

                #Warning Script
                WarningDateTime                = "Timestamp could not be converted to DateTime."
                WarningNewFileExist            = "New File           : This entry already exist and will not be added."
                WarningModifiedFileExist       = "Modified File      : This entry already exist and will not be added."
                WarningLonelyFileExist         = "Lonely File        : This entry already exist and will not be added."
                WarningNewerFileExist          = "Newer File         : This entry already exist and will not be added."
                WarningOlderFileExist          = "Older File         : This entry already exist and will not be added."
                WarningExtraFileExist          = "Extra File         : This entry already exist and will not be added."
                WarningTweakedFileExist        = "Tweaked File (Attr): This entry already exist and will not be added."
                WarningFailedFileExist         = "Failed File        : This entry already exist and will not be added."
                WarningFailedTimeFromInnerLog  = "Unable to calculate TotalTimeFromInnerLog due to incorrect date format in Robocopy log"
                WarningFailedTimeFromMetadata  = "Unable to calculate TotalTimeFromFile due to an error with the file metadata."
            }
            "fr-FR" = @{
                # Added non-breaking space (Unicode \u00A0)
                #RobocopParsing
                RobocopParsingStart    = "D$([char]0x00E9)but du parsing..."
                RobocopParsingFinalize = "Fin du parsing..."

                #Parsing header
                Start        = "D$([char]0x00E9)marrage$([char]0x00A0):"
                Source       = "Source :"
                Destination  = "Dest :"
                FilesSection = "Fichiers :"
                Options      = "Options :"
                
                #Parsing Files
                NewFile      = "Nouveau fichier"
                NewerFile    = "Plus r$([char]0x00E9)cent"
                OlderFile    = "Plus ancien"
                SameFile     = "identique"
                ExtraFile    = "Fichier SUPPL."
                ModifiedFile = "Modifi$([char]0x00E9)"
                LonelyFile   = "solitaire"
                TweakedFile  = "<TWEAKED F>"
                    
                #Parsing Directories
                NewDir       = "Nouveau r$([char]0x00E9)p."
                ExtraDir     = "R$([char]0x00E9)p. SUPPL."
                LonelyDir    = "solitaire"

                #Error
                Error             = "ERREUR"
                ErrorCopyFile     = "Copying File"
                ErrorDelFile      = "Deleting File"
                ErrorDelExtraFile = "Deleting Extra File"
                
                #Parsing Summary
                DirsSummary  = "R$([char]0x00E9)p$([char]0x00A0):"  
                FilesSummary = "Fichiers$([char]0x00A0):"
                Bytes        = "Octets$([char]0x00A0):"
                Times        = "Heures:"
                Ended        = "Fin :"

                #Warning Scripts
                WarningDateTime                = "L'horodatage n'a pas pu être converti en DateTime."
                WarningNewFileExist            = "Nouveau Fichier                     : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningModifiedFileExist       = "Fichier Modifi$([char]0x00E9)       : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningLonelyFileExist         = "Fichier Solitaire                   : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningNewerFileExist          = "Fichier R$([char]0x00E9)cent        : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningOlderFileExist          = "Fichier Ancien                      : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningExtraFileExist          = "Fichier Suppl.                      : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningTweakedFileExist        = "Fichier Tweaked (Attr)              : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningFailedFileExist         = "Fichier Echec                       : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningFailedTimeFromInnerLog  = "Impossible de calculer TotalTimeFromInnerLog en raison d'un format de date incorrect dans le journal Robocopy"
                WarningFailedTimeFromMetadata  = "Impossible de calculer TotalTimeFromFile en raison d'une erreur avec les m$([char]0x00E9)tadonn$([char]0x00E9)es du fichier."
            }
        }
        $Culture = $CultureMap[$LogLanguage]
    #endregion CultureMap

    #region Initialize OutputObject
        $Log = [pscustomobject]@{
            HeaderInfo = [pscustomobject]@{
                Start        = $null
                Source       = $null
                Destination  = $null
                FilesOptions = $null
                Options      = $null
            }
            Files = [pscustomobject]@{
                New          = @()
                Same         = @()
                Newer        = @()
                Older        = @()
                Extra        = @()
                Failed       = @()
                Modified     = @()
                Lonely       = @()
                Tweaked      = @()
            }
            Dirs = [pscustomobject]@{
                New          = @()
                Extra        = @()
                Lonely       = @()
            }
            SummaryInfo = [pscustomobject]@{
                Dirs  = [pscustomobject]@{
                    Total    = $null
                    Copied   = $null
                    Skipped  = $null
                    Mismatch = $null
                    Failed   = $null
                    Extras   = $null
                }
                Files = [pscustomobject]@{
                    Total    = $null
                    Copied   = $null
                    Skipped  = $null
                    Mismatch = $null
                    Failed   = $null
                    Extras   = $null
                }
                Ended                 = $null
                TotalTimeFromInnerLog = $null
                TotalTimeFromFile     = $null
            }
    }
    #endregion Initialize OutputObject

    #region Initialize LogLines
        $LogContent= Get-Content -Path $RoboLog -ReadCount 0
    #endregion Initialize LogLines

    #region Parsing LogContent
        #region Header
            $Log.HeaderInfo.Start = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Start)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Source = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Source)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Destination = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Destination)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.FilesOptions = $LogContent | Where-Object { $_ -match "^\s*$($Culture.FilesSection)\s*(.+)$" -and $_ -notmatch "\d" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Options = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Options)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
        #endregion Header

        #region Files and Directories
            <# 
                In the following regular expressions, the following elements are captured:
                    The file size (if present) with or without unit --> Allows to manage the Robocopy /NS and /Byte option
                    The timestamp (if present) --> Allows to manage the Robocopy /TS option
                    The full path of the file (local or UNC)
                    [^\\] : Test that the last character of the path is not a \, which identifies a file.
                    .+=[^\\] : This part captures any file path (with spaces or special characters) as long as it does not end with a backslash. 
            #>
            #region Classes : Files : NewFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "NewFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "NewFiles"))) {
                    $NewFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $NewFileClass | ForEach-Object {
                        <# 
                            Matches is reset with each new match. Even though Where-Object filters matching rows,
                            you have to rerun -match in the loop for each line and capture the matches in local variables
                            immediately, so as not to lose the data during subsequent iterations.
                        #>
                        if($_ -match "\s*$($Culture.NewFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            #Capture the raw file size (with or without units), if present
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }

                            #If a timestamp is captured, try to convert it to a DateTime object, else return a null value if datetime don't exist.
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }

                            #Capture the full path of the file
                            $filePath = $matches[3].Trim()

                            #Checking for file existence in $Log.Files.New list by comparing all properties
                            $NewFileExists = $Log.Files.New | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $NewFileExists){
                                # Adding the file to the list of new files (NewFiles) with its attributes
                                $Log.Files.New += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewFileExist) : $($NewFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion  Classes : Files : NewFile
            #region Classes : Files : ModifiedFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "ModifiedFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "ModifiedFiles"))) {
                    $ModifiedFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ModifiedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $ModifiedFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ModifiedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $ModifiedFileExists = $Log.Files.Modified | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $ModifiedFileExists){
                                $Log.Files.Modified += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningModifiedFileExist) : $($ModifiedFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : ModifiedFile
            #region Classes : Files : LonelyFile 
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "LonelyFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "LonelyFiles"))) {
                    $LonelyFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.LonelyFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $LonelyFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.LonelyFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $LonelyFileExists = $Log.Files.Lonely | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $LonelyFileExists){
                                $Log.Files.Lonely += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningLonelyFileExist) : $($LonelyFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : LonelyFile
            #region Classes : Files : SameFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "SameFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "SameFiles"))) {
                    $SameFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.SameFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $SameFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.SameFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $SameFileExists = $Log.Files.Same | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $SameFileExists){
                                $Log.Files.Same += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningSameFileExist) : $($SameFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : SameFile
            #region Classes : Files : NewerFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "NewerFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "NewerFiles"))) {
                    $NewerFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewerFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $NewerFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.NewerFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $NewerFileExists = $Log.Files.Newer | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $NewerFileExists){
                                $Log.Files.Newer += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewerFileExist) : $($NewerFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : NewerFile
            #region Classes : Files : OlderFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "OlderFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "OlderFiles"))) {
                    $OlderFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.OlderFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $OlderFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.OlderFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $OlderFileExists = $Log.Files.Older | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $OlderFileExists){
                                $Log.Files.Older += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningOlderFileExist) : $($OlderFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : OlderFile
            #region Classes : Files : ExtraFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "ExtraFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "ExtraFiles"))) {
                    $ExtraFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ExtraFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $ExtraFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ExtraFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $ExtraFileExists = $Log.Files.Extra | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $ExtraFileExists){
                                $Log.Files.Extra += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningExtraFileExist) : $($ExtraFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : ExtraFile
            #Region Classes : Files : TweakedFile
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "TweakedFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "TweakedFiles"))) {
                    $TweakedFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.TweakedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $TweakedFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.TweakedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $TweakedFileExists = $Log.Files.Tweaked | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $TweakedFileExists){
                                $Log.Files.Tweaked += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningTweakedFileExist) : $($TweakedFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Classes : Files : TweakedFile
            #region Files : FailedFiles
                if (($IncludeFileClass -contains "All" -or $IncludeFileClass -contains "FailedFiles") -and (-not ($ExcludeFileClass -contains "All") -and -not ($ExcludeFileClass -contains "FailedFiles"))) {
                    #This just capture the failed files when there is a line with Error, Copying File, Deleting File, Deleting Extra File. There isn't a Classes for FailedFiles.
                    $FailedFiles = @($LogContent | Where-Object { $_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$" })
                    $FailedFiles | ForEach-Object {
                        if($_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$"){
                            $filePath = $Matches[4].Trim()   
                            $errorInfo = "$($Matches[1]) $($Matches[2])"  # Error code and error number
                            $errorAction = $Matches[3].Trim()    # Action (Copying File, Deleting File, etc.)

                            $FailedFileExists = $Log.Files.Failed | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.ErrorInfo -eq $errorInfo -and
                                $_.ErrorAction -eq $errorAction
                            }
            
                            if (-not $FailedFileExists) {
                                $Log.Files.Failed += [pscustomobject]@{
                                    FilePath    = $filePath    
                                    ErrorInfo   = $errorInfo   
                                    ErrorAction = $errorAction 
                                }
                            } else {
                                Write-Warning "$($Culture.WarningFailedFileExist) : $($FailedFileExists.FilePath)"
                            }
                        }
                    }
                }
            #endregion Files : FailedFiles
            #region Classes : Directories : NewDir
                if(($IncludeDirClass -contains "All" -or $IncludeDirClass -contains "NewDirs") -and (-not ($ExcludeDirClass -contains "All") -and -not ($ExcludeDirClass -contains "NewDirs"))){
                    $NewDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $NewDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.NewDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $NewDirExists = $Log.Dirs.New | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $NewDirExists){
                                $Log.Dirs.New += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewDirExist) : $($NewDirExists.DirPath)"
                            }
                        }
                    }
                }
            #endregion Classes : Directories : NewDir
            #region Classes : Directories : ExtraDir
                if(($IncludeDirClass -contains "All" -or $IncludeDirClass -contains "ExtraDirs") -and (-not ($ExcludeDirClass -contains "All") -and -not ($ExcludeDirClass -contains "ExtraDirs"))){
                    $ExtraDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ExtraDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $ExtraDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ExtraDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $ExtraDirExists = $Log.Dirs.Extra | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $ExtraDirExists){
                                $Log.Dirs.Extra += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningExtraDirExist) : $($ExtraDirExists.DirPath)"
                            }
                        }
                    }
                }
            #endregion Classes : Directories : ExtraDir
            #region Classes : Directories : LonelyDir
                if(($IncludeDirClass -contains "All" -or $IncludeDirClass -contains "LonelyDirs") -and (-not ($ExcludeDirClass -contains "All") -and -not ($ExcludeDirClass -contains "LonelyDirs"))){
                    $LonelyDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.LonelyDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $LonelyDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.LonelyDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $LonelyDirExists = $Log.Dirs.Lonely | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $LonelyDirExists){
                                $Log.Dirs.Lonely += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningLonelyDirExist) : $($LonelyDirExists.DirPath)"
                            }
                        }
                    }
                }
            #endregion Classes : Directories : LonelyDir
        #endregion Files and Directories


        #region Summary
            #region Directories
                $SummaryDirectories = $LogContent | Where-Object { $_ -match "^\s*$($Culture.DirsSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }
                if($SummaryDirectories){
                    $Log.SummaryInfo.Dirs.Total    = [int]$matches[1]
                    $Log.SummaryInfo.Dirs.Copied   = [int]$matches[2]
                    $Log.SummaryInfo.Dirs.Skipped  = [int]$matches[3]
                    $Log.SummaryInfo.Dirs.Mismatch = [int]$matches[4]
                    $Log.SummaryInfo.Dirs.Failed   = [int]$matches[5]
                    $Log.SummaryInfo.Dirs.Extras   = [int]$matches[6]
                }
            #endregion Directories
            #region Files
                $SummaryFiles = $LogContent | Where-Object { $_ -match "^\s*$($Culture.FilesSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }
                if($SummaryFiles){
                    $Log.SummaryInfo.Files.Total    = [int]$matches[1]
                    $Log.SummaryInfo.Files.Copied   = [int]$matches[2]
                    $Log.SummaryInfo.Files.Skipped  = [int]$matches[3]
                    $Log.SummaryInfo.Files.Mismatch = [int]$matches[4]
                    $Log.SummaryInfo.Files.Failed   = [int]$matches[5]
                    $Log.SummaryInfo.Files.Extras   = [int]$matches[6]
                }
            #endregion Files
            #region Ended Datetime
                $SummaryEnded = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Ended)\s*(.+)$" }
                if($SummaryEnded){
                    $Log.SummaryInfo.Ended = $Matches[1].Trim()
                }
            #endregion Ended Datetime 
        #endregion Summary
    #endregion Parsing LogContent
    
    #region Calculation Extra data
        # Calculate total time based on HeaderInfo.Start and SummaryInfo.Ended if exists
        if ($Log.HeaderInfo.Start -and $Log.SummaryInfo.Ended) {
            try {
                # Use Get-Date to convert dates
                $startTime = Get-Date -Date $Log.HeaderInfo.Start
                $endTime = Get-Date -Date $Log.SummaryInfo.Ended

                # Calculation of duration
                $duration = $endTime - $startTime

                # Formatting the result in Days:Hours:Minutes:Seconds
                $Log.SummaryInfo.TotalTimeFromInnerLog = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $duration.Days, $duration.Hours, $duration.Minutes, $duration.Seconds
            }
            catch {
                Write-Warning "Impossible de calculer TotalTimeFromInnerLog en raison d'un format de date incorrect dans le journal Robocopy"
            }
        }

        # Calculation of total time based on file metadata (creation and modification)
        try {
            $fileInfo = Get-Item $RoboLog
            $creationTime = $fileInfo.CreationTime
            $lastWriteTime = $fileInfo.LastWriteTime

            # If the creation date is greater than the modification date, the dates are reversed
			# I had this case when creating a file on a server with time out of sync and file re-modified on another machine with another timeset
            if ($creationTime -gt $lastWriteTime) {
                $fileDuration = $creationTime - $lastWriteTime
            } else {
                $fileDuration = $lastWriteTime - $creationTime
            }

            $Log.SummaryInfo.TotalTimeFromFile = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $fileDuration.Days, $fileDuration.Hours, $fileDuration.Minutes, $fileDuration.Seconds
        }
        catch {
            Write-Warning "Impossible de calculer TotalTimeFromFile en raison d'une erreur avec les métadonnées du fichier."
        }
    #endregion END Calculation Extra data

    return $Log
}

try {
    # Construction of the dynamic call based on the parameters provided
    $params = @{
        RoboLog         = $RoboLog
        LogLanguage     = $LogLanguage
        IncludeFileClass = $IncludeFileClass
        IncludeDirClass = $IncludeDirClass
    }

    if ($ExcludeFileClass) {
        $params["ExcludeFileClass"] = $ExcludeFileClass
    }
    if ($ExcludeDirClass) {
        $params["ExcludeDirClass"] = $ExcludeDirClass
    }

    return (ConvertFrom-RobocopLog @params)
} catch {
    Write-Error $_
}