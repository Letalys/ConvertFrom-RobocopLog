<#
.SYNOPSIS
    Analyzes and converts a Robocopy log file into a structured PowerShell object.

.DESCRIPTION
    The `ConvertFrom-RobocopLog` script parses a log file generated by Robocopy and extracts header information, 
    a list of files according to their Robocopy class, created directories, and summary statistics.
    
    It handles logs in both English and French and returns a PowerShell object containing the extracted data.
    The script is compatible with various Robocopy options, but some are required or prohibited for optimal functioning. (see the Notes section)

.PARAMETER RoboLog
    (Mandatory) The path to the Robocopy log file to analyze.

.PARAMETER LogLanguage
    (Optional) Specifies the log file language. Defaults to "en-US". Available options are "en-US" and "fr-FR".

.PARAMETER ParseType
    (Optional) Specifies the type of parsing, either full or only parsing the header and summary if they exist. Available options are "Full" and "NoParseFile".
                This option can help reduce processing time if the log file is substantial in terms of lines to be processed.

.EXAMPLE
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.txt"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.txt" -LogLanguage "en-US" -ParseType "Full"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -LogLanguage "fr-FR"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -LogLanguage "fr-FR" -ParseType "NoParseFile"
    
    $Log.HeaderInfo       : Provides the header information if available.
    $Log.HeaderInfo.Start : Provides the start date and time from the header if available.
    $Log.Files.NewFiles   : Provides the list of new files (along with size and timestamp depending on the Robocopy options).
    $Log.SummaryInfo      : Provides the summary information if available.

    $Log | Get-Member     : Use to get a list of properties from the returned object.

.NOTES
    WARNING               : For this script to work properly, certain Robocopy log options must be considered.
								(REQUIRED OPTION)  /fp              : Ensures that full file paths are logged.
								(FORBIDDEN OPTION) /nc              : Specifies that file classes will not be recorded.

								(fr-FR OPTION)     /unicode:<Log>   : To be used instead of /log for proper handling of accents.
                                                                      Be aware that in Unicode, some characters are non-breaking.
                                                                      They must be directly added to the culture map. Check fr-FR CultureMap.

                            More info: https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy

							Some data is not converted, including:
								- Folders that have not changed.
								- Copy speed from the summary.
								- Total size of the copied files from the summary.

							The script takes into account retries. In case of retries, Robocopy will reattempt classes and errors.
							A check is therefore performed to ensure that errors or file classes are not already included in the objects to avoid duplicates.
                         

    ROBOCOPY CLASSES en-US  :   File        Exists In   Exists In        Source/Dest     Source/Dest    Source/Dest
                                Class       Source      Destination      File Times      File Sizes     Attributes
                                =========== =========== ================ =============== =============  ============
                                Lonely      Yes         No               n/a             n/a            n/a
                                Tweaked     Yes         Yes              Equal           Equal          Different
                                Same        Yes         Yes              Equal           Equal          Equal
                                Changed     Yes         Yes              Equal           Different      n/a
                                Newer       Yes         Yes              Source > Dest   n/a            n/a
                                Older       Yes         Yes              Source < Dest   n/a            n/a
                                Extra       No          Yes              n/a             n/a            n/a
                                Mismatched  Yes (file)  Yes (directory)  n/a             n/a            n/a

    ROBOCOPY CLASSES fr-FR  :   Classe de   Existe dans Existe dans      Source/Dest     Source/Dest    Source/Dest
                                Fichier     la Source   la Destination   Date fichier    Taille fichier Attributs
                                =========== =========== ================ =============== =============  ============
                                solitaire   Oui         Non              n/a             n/a            n/a
                                Tweaked     Oui         Oui              Identique       Identique      Différent
                                identique   Oui         Oui              Equal           Identique      Identique
                                Modifié     Oui         Oui              Equal           Different      n/a
                                Plus récent Oui         Oui              Source > Dest   n/a            n/a
                                Plus ancien Oui         Oui              Source < Dest   n/a            n/a
                                Supplément. Non         Oui              n/a             n/a            n/a
                                Discordance Yes (Fic)   Yes (Rép)        n/a             n/a            n/a

    AUTHOR              : Letalys

    SCRIPT              : ConvertFrom-RobocopLog.ps1
    SCRIPTVERSION       : 2.0

    RELEASENOTES        : Version 1.0  | 2024-09-26
                                Initial version.
			              Version 1.01 | 2024-09-27
                               Bug fix : When the $ParseType option was full, the end summary was not correctly parsed due to a bad condition
                          Version 2.0 | 2024-10-27
                                Issue #2 : New Method to browse log file. This script now integrate the log file into an array and browse it.

#>

param (
    [Parameter(Mandatory = $true)][ValidateScript({ Test-Path -Path $_ })][String]$RoboLog,
    [Parameter(Mandatory = $false)][ValidateSet("en-US", "fr-FR")][String]$LogLanguage = "en-US",
    [Parameter(Mandatory = $false)][ValidateSet("Full", "NoParseFile")][String]$ParseType = "Full"
)

function ConvertFrom-RobocopLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)][ValidateScript({ Test-Path -Path $_ })][String]$RoboLog,
        [Parameter(Mandatory = $false)][ValidateSet("en-US", "fr-FR")][String]$LogLanguage = "en-US",
        [Parameter(Mandatory = $false)][ValidateSet("Full", "NoParseFile")][String]$ParseType = "Full"
    )

    #region CultureMap
        #Management of keyword dictionaries according to language.
        $CultureMap = @{
            "en-US" = @{
                #RobocopParsing
                RobocopParsingStart    = "Start parsing..."
                RobocopParsingFinalize = "End parsing..."

                #Parsing header
                Start        = "Started :"
                Source       = "Source :"
                Destination  = "Dest :"
                FilesSection = "Files :"
                Options      = "Options :"

                #Parsing Files
                NewFile      = "New File"
                NewerFile    = "Newer"
                OlderFile    = "Older"
                SameFile     = "same"
                ExtraFile    = "EXTRA File"
                ModifiedFile = "Modified"
                LonelyFile   = "lonely"
                TweakedFile  = "tweaked"

                #Parsing Directories
                NewDir       = "New Dir"
                ExtraDir     = "EXTRA Dir"
                LonelyDir    = "lonely"

                #Error
                Error             = "ERROR"
                ErrorCopyFile     = "Copying File"
                ErrorDelFile      = "Deleting File"
                ErrorDelExtraFile = "Deleting Extra File"

                #Parsing Summary
                DirsSummary  = "Dirs :"
                FilesSummary = "Files :"
                Bytes        = "Bytes :"
                Times        = "Times :"
                Ended        = "Ended :"

                #Warning Script
                WarningDateTime                = "Timestamp could not be converted to DateTime."
                WarningNewFileExist            = "New File           : This entry already exist and will not be added."
                WarningModifiedFileExist       = "Modified File      : This entry already exist and will not be added."
                WarningLonelyFileExist         = "Lonely File        : This entry already exist and will not be added."
                WarningNewerFileExist          = "Newer File         : This entry already exist and will not be added."
                WarningOlderFileExist          = "Older File         : This entry already exist and will not be added."
                WarningExtraFileExist          = "Extra File         : This entry already exist and will not be added."
                WarningTweakedFileExist        = "Tweaked File (Attr): This entry already exist and will not be added."
                WarningFailedFileExist         = "Failed File        : This entry already exist and will not be added."
                WarningFailedTimeFromInnerLog  = "Unable to calculate TotalTimeFromInnerLog due to incorrect date format in Robocopy log"
                WarningFailedTimeFromMetadata  = "Unable to calculate TotalTimeFromFile due to an error with the file metadata."
            }
            "fr-FR" = @{
                # Added non-breaking space (Unicode \u00A0)
                #RobocopParsing
                RobocopParsingStart    = "D$([char]0x00E9)but du parsing..."
                RobocopParsingFinalize = "Fin du parsing..."

                #Parsing header
                Start        = "D$([char]0x00E9)marrage$([char]0x00A0):"
                Source       = "Source :"
                Destination  = "Dest :"
                FilesSection = "Fichiers :"
                Options      = "Options :"
                
                #Parsing Files
                NewFile      = "Nouveau fichier"
                NewerFile    = "Plus r$([char]0x00E9)cent"
                OlderFile    = "Plus ancien"
                SameFile     = "identique"
                ExtraFile    = "Fichier SUPPL."
                ModifiedFile = "Modifi$([char]0x00E9)"
                LonelyFile   = "solitaire"
                TweakedFile  = "<TWEAKED F>"
                    
                #Parsing Directories
                NewDir       = "Nouveau r$([char]0x00E9)p."
                ExtraDir     = "R$([char]0x00E9)p. SUPPL."
                LonelyDir    = "solitaire"

                #Error
                Error             = "ERREUR"
                ErrorCopyFile     = "Copying File"
                ErrorDelFile      = "Deleting File"
                ErrorDelExtraFile = "Deleting Extra File"
                
                #Parsing Summary
                DirsSummary  = "R$([char]0x00E9)p$([char]0x00A0):"  
                FilesSummary = "Fichiers$([char]0x00A0):"
                Bytes        = "Octets$([char]0x00A0):"
                Times        = "Heures:"
                Ended        = "Fin :"

                #Warning Scripts
                WarningDateTime                = "L'horodatage n'a pas pu être converti en DateTime."
                WarningNewFileExist            = "Nouveau Fichier                     : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningModifiedFileExist       = "Fichier Modifi$([char]0x00E9)       : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningLonelyFileExist         = "Fichier Solitaire                   : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningNewerFileExist          = "Fichier R$([char]0x00E9)cent        : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningOlderFileExist          = "Fichier Ancien                      : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningExtraFileExist          = "Fichier Suppl.                      : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningTweakedFileExist        = "Fichier Tweaked (Attr)              : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningFailedFileExist         = "Fichier Echec                       : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)j$([char]0x00E0) et ne sera pas ajout$([char]0x00E9)e."
                WarningFailedTimeFromInnerLog  = "Impossible de calculer TotalTimeFromInnerLog en raison d'un format de date incorrect dans le journal Robocopy"
                WarningFailedTimeFromMetadata  = "Impossible de calculer TotalTimeFromFile en raison d'une erreur avec les m$([char]0x00E9)tadonn$([char]0x00E9)es du fichier."
            }
        }
        $Culture = $CultureMap[$LogLanguage]
    #endregion CultureMap

    #region Initialize OutputObject
        $Log = [pscustomobject]@{
            HeaderInfo = [pscustomobject]@{
                Start        = $null
                Source       = $null
                Destination  = $null
                FilesOptions = $null
                Options      = $null
            }
            Files = [pscustomobject]@{
                New          = @()
                Same         = @()
                Newer        = @()
                Older        = @()
                Extra        = @()
                Failed       = @()
                Modified     = @()
                Lonely       = @()
                Tweaked      = @()
            }
            Dirs = [pscustomobject]@{
                New          = @()
                Extra        = @()
                Lonely       = @()
            }
            SummaryInfo = [pscustomobject]@{
                Dirs  = [pscustomobject]@{
                    Total    = $null
                    Copied   = $null
                    Skipped  = $null
                    Mismatch = $null
                    Failed   = $null
                    Extras   = $null
                }
                Files = [pscustomobject]@{
                    Total    = $null
                    Copied   = $null
                    Skipped  = $null
                    Mismatch = $null
                    Failed   = $null
                    Extras   = $null
                }
                Ended                 = $null
                TotalTimeFromInnerLog = $null
                TotalTimeFromFile     = $null
            }
    }
    #endregion Initialize OutputObject

    #region Initialize LogLines
        $LogContent= Get-Content -Path $RoboLog -ReadCount 0
    #endregion Initialize LogLines

    #region Parsing LogContent
        #region Header
            $Log.HeaderInfo.Start = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Start)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Source = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Source)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Destination = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Destination)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.FilesOptions = $LogContent | Where-Object { $_ -match "^\s*$($Culture.FilesSection)\s*(.+)$" -and $_ -notmatch "\d" } | ForEach-Object { $Matches[1].Trim() }
            $Log.HeaderInfo.Options = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Options)\s*(.+)$" } | ForEach-Object { $Matches[1].Trim() }
        #endregion Header

        if($ParseType -eq "Full"){
            #region Files and Directories
                <# 
                    In the following regular expressions, the following elements are captured:
                        The file size (if present) with or without unit --> Allows to manage the Robocopy /NS and /Byte option
                        The timestamp (if present) --> Allows to manage the Robocopy /TS option
                        The full path of the file (local or UNC)
                        [^\\] : Test that the last character of the path is not a \, which identifies a file.
                        .+=[^\\] : This part captures any file path (with spaces or special characters) as long as it does not end with a backslash. 
                #>
                #region Classes : Files : NewFile
                    $NewFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $NewFileClass | ForEach-Object {
                        <# 
                            Matches is reset with each new match. Even though Where-Object filters matching rows,
                            you have to rerun -match in the loop for each line and capture the matches in local variables
                            immediately, so as not to lose the data during subsequent iterations.
                        #>
                        if($_ -match "\s*$($Culture.NewFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            #Capture the raw file size (with or without units), if present
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }

                            #If a timestamp is captured, try to convert it to a DateTime object, else return a null value if datetime don't exist.
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }

                            #Capture the full path of the file
                            $filePath = $matches[3].Trim()

                            #Checking for file existence in $Log.Files.New list by comparing all properties
                            $NewFileExists = $Log.Files.New | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $NewFileExists){
                                # Adding the file to the list of new files (NewFiles) with its attributes
                                $Log.Files.New += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewFileExist) : $($NewFileExists.FilePath)"
                            }
                        }
                    }
                #endregion  Classes : Files : NewFile
                #region Classes : Files : ModifiedFile
                    $ModifiedFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ModifiedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $ModifiedFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ModifiedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $ModifiedFileExists = $Log.Files.Modified | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $ModifiedFileExists){
                                $Log.Files.Modified += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningModifiedFileExist) : $($ModifiedFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : ModifiedFile
                #region Classes : Files : LonelyFile 
                    $LonelyFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.LonelyFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $LonelyFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.LonelyFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $LonelyFileExists = $Log.Files.Lonely | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $LonelyFileExists){
                                $Log.Files.Lonely += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningLonelyFileExist) : $($LonelyFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : LonelyFile
                #region Classes : Files : SameFile
                    $SameFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.SameFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $SameFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.SameFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $SameFileExists = $Log.Files.Same | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $SameFileExists){
                                $Log.Files.Same += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningSameFileExist) : $($SameFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : SameFile
                #region Classes : Files : NewerFile
                    $NewerFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewerFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $NewerFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.NewerFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $NewerFileExists = $Log.Files.Newer | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $NewerFileExists){
                                $Log.Files.Newer += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewerFileExist) : $($NewerFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : NewerFile
                #region Classes : Files : OlderFile
                    $OlderFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.OlderFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $OlderFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.OlderFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $OlderFileExists = $Log.Files.Older | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $OlderFileExists){
                                $Log.Files.Older += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningOlderFileExist) : $($OlderFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : OlderFile
                #region Classes : Files : ExtraFile
                    $ExtraFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ExtraFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $ExtraFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ExtraFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $ExtraFileExists = $Log.Files.Extra | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $ExtraFileExists){
                                $Log.Files.Extra += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningExtraFileExist) : $($ExtraFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : ExtraFile
                #Region Classes : Files : TweakedFile
                    $TweakedFileClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.TweakedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$" })
                    $TweakedFileClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.TweakedFile)\s+([\d\.]+(?:\s*\w+)?)?\s*(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2})?\s*(\w:[\\/].+|\\\\.+)$"){
                            $fileSizeRaw = if ($matches[1]) { $matches[1].Trim() } else { $null }
                            $fileTimestamp = if ($matches[2]) { [datetime]::ParseExact($matches[2].Trim(), "yyyy/MM/dd HH:mm:ss", $null) } else { $null }
                            $filePath = $matches[3].Trim()

                            $TweakedFileExists = $Log.Files.Tweaked | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.FileSize -eq $fileSizeRaw -and
                                $_.Timestamp -eq $fileTimestamp
                            }

                            if(-not $TweakedFileExists){
                                $Log.Files.Tweaked += [pscustomobject]@{
                                    FilePath   = $filePath    
                                    FileSize   = $fileSizeRaw  
                                    Timestamp  = $fileTimestamp 
                                }
                            }else{
                                Write-Warning "$($Culture.WarningTweakedFileExist) : $($TweakedFileExists.FilePath)"
                            }
                        }
                    }
                #endregion Classes : Files : TweakedFile
                #region Files : FailedFiles
                    #This just capture the failed files when there is a line with Error, Copying File, Deleting File, Deleting Extra File. There isn't a Classes for FailedFiles.
                    $FailedFiles = @($LogContent | Where-Object { $_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$" })
                    $FailedFiles | ForEach-Object {
                        if($_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$"){
                            $filePath = $Matches[4].Trim()   
                            $errorInfo = "$($Matches[1]) $($Matches[2])"  # Error code and error number
                            $errorAction = $Matches[3].Trim()    # Action (Copying File, Deleting File, etc.)

                            $FailedFileExists = $Log.Files.Failed | Where-Object {
                                $_.FilePath -eq $filePath -and
                                $_.ErrorInfo -eq $errorInfo -and
                                $_.ErrorAction -eq $errorAction
                            }
            
                            if (-not $FailedFileExists) {
                                $Log.Files.Failed += [pscustomobject]@{
                                    FilePath    = $filePath    
                                    ErrorInfo   = $errorInfo   
                                    ErrorAction = $errorAction 
                                }
                            } else {
                                Write-Warning "$($Culture.WarningFailedFileExist) : $($FailedFileExists.FilePath)"
                            }
                        }
                    }

                #endregion Files : FailedFiles
                #region Classes : Directories : NewDir
                    $NewDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.NewDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $NewDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.NewDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $NewDirExists = $Log.Dirs.New | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $NewDirExists){
                                $Log.Dirs.New += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningNewDirExist) : $($NewDirExists.DirPath)"
                            }
                        }
                    }
                #endregion Classes : Directories : NewDir
                #region Classes : Directories : ExtraDir
                    $ExtraDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.ExtraDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $ExtraDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.ExtraDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $ExtraDirExists = $Log.Dirs.Extra | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $ExtraDirExists){
                                $Log.Dirs.Extra += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningExtraDirExist) : $($ExtraDirExists.DirPath)"
                            }
                        }
                    }
                #endregion Classes : Directories : ExtraDir
                #region Classes : Directories : LonelyDir
                    $LonelyDirClass = @($LogContent | Where-Object { $_ -match "\s*$($Culture.LonelyDir)\s+(\w:[\\/].+|\\\\.+)$" })
                    $LonelyDirClass | ForEach-Object {
                        if($_ -match "\s*$($Culture.LonelyDir)\s+(\w:[\\/].+|\\\\.+)$"){
                            $dirPath = $matches[1].Trim()

                            $LonelyDirExists = $Log.Dirs.Lonely | Where-Object {
                                $_.DirPath -eq $dirPath
                            }

                            if(-not $LonelyDirExists){
                                $Log.Dirs.Lonely += [pscustomobject]@{
                                    DirPath = $dirPath
                                }
                            }else{
                                Write-Warning "$($Culture.WarningLonelyDirExist) : $($LonelyDirExists.DirPath)"
                            }
                        }
                    }
                #endregion Classes : Directories : LonelyDir
            #endregion Files and Directories
        }

        #region Summary
            #region Directories
                $SummaryDirectories = $LogContent | Where-Object { $_ -match "^\s*$($Culture.DirsSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }
                if($SummaryDirectories){
                    $Log.SummaryInfo.Dirs.Total    = [int]$matches[1]
                    $Log.SummaryInfo.Dirs.Copied   = [int]$matches[2]
                    $Log.SummaryInfo.Dirs.Skipped  = [int]$matches[3]
                    $Log.SummaryInfo.Dirs.Mismatch = [int]$matches[4]
                    $Log.SummaryInfo.Dirs.Failed   = [int]$matches[5]
                    $Log.SummaryInfo.Dirs.Extras   = [int]$matches[6]
                }
            #endregion Directories
            #region Files
                $SummaryFiles = $LogContent | Where-Object { $_ -match "^\s*$($Culture.FilesSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }
                if($SummaryFiles){
                    $Log.SummaryInfo.Files.Total    = [int]$matches[1]
                    $Log.SummaryInfo.Files.Copied   = [int]$matches[2]
                    $Log.SummaryInfo.Files.Skipped  = [int]$matches[3]
                    $Log.SummaryInfo.Files.Mismatch = [int]$matches[4]
                    $Log.SummaryInfo.Files.Failed   = [int]$matches[5]
                    $Log.SummaryInfo.Files.Extras   = [int]$matches[6]
                }
            #endregion Files
            #region Ended Datetime
                $SummaryEnded = $LogContent | Where-Object { $_ -match "^\s*$($Culture.Ended)\s*(.+)$" }
                if($SummaryEnded){
                    $Log.SummaryInfo.Ended = $Matches[1].Trim()
                }
            #endregion Ended Datetime 
        #endregion Summary
    #endregion Parsing LogContent
    
    #region Calculation Extra data
        # Calculate total time based on HeaderInfo.Start and SummaryInfo.Ended if exists
        if ($Log.HeaderInfo.Start -and $Log.SummaryInfo.Ended) {
            try {
                # Use Get-Date to convert dates
                $startTime = Get-Date -Date $Log.HeaderInfo.Start
                $endTime = Get-Date -Date $Log.SummaryInfo.Ended

                # Calculation of duration
                $duration = $endTime - $startTime

                # Formatting the result in Days:Hours:Minutes:Seconds
                $Log.SummaryInfo.TotalTimeFromInnerLog = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $duration.Days, $duration.Hours, $duration.Minutes, $duration.Seconds
            }
            catch {
                Write-Warning "Impossible de calculer TotalTimeFromInnerLog en raison d'un format de date incorrect dans le journal Robocopy"
            }
        }

        # Calculation of total time based on file metadata (creation and modification)
        try {
            $fileInfo = Get-Item $RoboLog
            $creationTime = $fileInfo.CreationTime
            $lastWriteTime = $fileInfo.LastWriteTime

            # If the creation date is greater than the modification date, the dates are reversed
			# I had this case when creating a file on a server with time out of sync and file re-modified on another machine with another timeset
            if ($creationTime -gt $lastWriteTime) {
                $fileDuration = $creationTime - $lastWriteTime
            } else {
                $fileDuration = $lastWriteTime - $creationTime
            }

            $Log.SummaryInfo.TotalTimeFromFile = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $fileDuration.Days, $fileDuration.Hours, $fileDuration.Minutes, $fileDuration.Seconds
        }
        catch {
            Write-Warning "Impossible de calculer TotalTimeFromFile en raison d'une erreur avec les métadonnées du fichier."
        }
    #endregion END Calculation Extra data

    return $Log
}

try{
    return (ConvertFrom-RobocopLog -RoboLog $RoboLog -LogLanguage $LogLanguage -ParseType $ParseType)
}catch{
    Write-Error $_
}